# 第8章：规划算法 - 从规则到学习

## 引言

规划算法是自动驾驶系统的"大脑中枢"，负责在复杂动态环境中生成安全、舒适、高效的驾驶轨迹。从2016年到2024年，规划算法经历了从纯规则驱动到数据驱动、从确定性算法到概率性推理、从单体智能到多智能体博弈的深刻变革。本章将深入剖析这一演进历程中的关键技术突破、工程实践和未来趋势。

## 1. 传统规划方法的基石与局限

### 1.1 基于搜索的规划算法

#### A*算法在自动驾驶中的应用

A*算法作为最经典的图搜索算法，在早期自动驾驶系统中扮演了重要角色。其核心思想是通过启发式函数引导搜索方向，在保证最优性的同时提高搜索效率。从2016年开始，几乎所有主流自动驾驶系统都将A*或其变种作为基础规划算法。

```
A*算法在自动驾驶中的典型应用架构：

┌─────────────────────────────────────────────────┐
│                  环境表征层                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │ 栅格地图 │  │ 语义地图 │  │ 成本地图 │    │
│  │ 0.1-1.0m │  │ 车道/路口 │  │ 风险评估 │    │
│  └──────────┘  └──────────┘  └──────────┘    │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│                  A*搜索引擎                     │
│  ┌──────────────────────────────────────┐      │
│  │  f(n) = g(n) + h(n)                  │      │
│  │  g(n): 起点到n的实际代价              │      │
│  │  h(n): n到终点的启发式估计            │      │
│  │  ε-admissible: f(n) ≤ (1+ε)·f*(n)   │      │
│  └──────────────────────────────────────┘      │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│                 轨迹后处理                       │
│  • 路径平滑 (Cubic Spline, Bezier)             │
│  • 速度规划 (S-T图优化)                        │
│  • 碰撞检测与避让                              │
│  • 曲率连续性保证                              │
└─────────────────────────────────────────────────┘
```

**深度技术剖析：**

1. **分辨率权衡与自适应策略**：
   - 高分辨率(0.1m)：精度高但计算量O(n⁴)，适合低速泊车场景(<10km/h)
   - 中分辨率(0.25m)：平衡精度与效率，城市道路主流选择(10-60km/h)
   - 低分辨率(0.5-1m)：计算快O(n²)，高速公路场景(>60km/h)
   - **自适应分辨率**(Waymo, 2018)：近处密集远处稀疏，计算效率提升3倍

2. **启发式函数的演进**：
   ```
   基础启发式：
   - 欧氏距离: h(n) = ||n - goal||₂
   - 曼哈顿距离: h(n) = |nx-gx| + |ny-gy|
   
   运动学感知启发式：
   - Dubins路径: 考虑最小转弯半径
   - Reeds-Shepp: 允许倒车的最短路径
   
   高级启发式(2019+)：
   - 全息成本: h(n) = α·距离 + β·舒适度 + γ·风险
   - 学习型启发式: h(n) = Neural_Network(state)
   ```

3. **实时性优化技术栈**：
   - **Anytime A*** (2016-2018主流)：
     * 初始ε=3.0快速获得可行解
     * 渐进收缩ε→1.0逼近最优
     * 典型收敛时间：10ms→50ms→100ms
   
   - **D* Lite** (动态环境必备)：
     * 增量式更新，避免全局重搜索
     * 仅传播受影响节点，复杂度O(k·log k)
     * Uber ATG实践：处理动态障碍物延迟<5ms
   
   - **Hybrid A*** (Stanford/Mercedes开创)：
     * 离散网格搜索+连续空间优化
     * 考虑车辆完整运动学模型
     * 泊车场景成功率：95%→99.5%

**产业化实践案例深度分析：**

**Apollo早期版本(2.0-3.0)的层次化A*架构：**
```
第一层：道路级规划(10Hz)
├─ 输入：路网拓扑图
├─ 输出：车道序列
└─ 搜索空间：~100节点

第二层：车道级规划(20Hz)
├─ 输入：车道中心线
├─ 输出：粗略轨迹
└─ 搜索空间：~1000节点

第三层：轨迹级优化(50Hz)
├─ 输入：粗略轨迹
├─ 输出：平滑轨迹
└─ 优化维度：位置+速度+加速度
```

**关键性能指标：**
- 搜索成功率：99.8%（结构化道路）
- 平均搜索时间：15ms（城市场景）
- 内存占用：<100MB（包含多层地图）

**Hybrid A*在Mercedes S-Class (2017)的工程化：**
```
状态空间扩展：
State = [x, y, θ, v, δ]
- (x,y): 2D位置
- θ: 航向角(离散化72个方向)
- v: 速度(离散化10个等级)
- δ: 前轮转角

运动原语设计：
1. 直行: δ=0, 不同速度
2. 左转: δ∈[-δmax, 0), 5个级别
3. 右转: δ∈(0, δmax], 5个级别
4. 倒车: v<0, 用于泊车

碰撞检测优化：
- Swept Volume预计算
- 2D查找表加速
- 检测速度：<0.1ms/查询
```

**Google自动驾驶项目(2014-2016)的分层A*创新：**
1. **全局A***：高精地图上的拓扑搜索
2. **局部A***：100m范围内的精细规划
3. **紧急A***：10m范围内的避障专用
4. **并行化**：3个A*实例并行运行，取最优解

#### RRT系列算法的演进

快速扩展随机树(RRT)通过随机采样探索配置空间，特别适合高维空间和复杂约束下的规划问题。RRT由LaValle于1998年提出后，迅速成为机器人路径规划的主流方法，并在2010年后广泛应用于自动驾驶领域。

```
RRT算法家族完整演进图谱：

         RRT (LaValle, 1998)
         概率完备，非最优
              ↓
      ┌───────┴───────┐
      ↓               ↓
   RRT-Connect    RRT-GoalBias
   (2000)         (1999)
   双向生长        目标偏置
      ↓               ↓
   Bi-RRT ←────────→ RRT*
   (2001)           (2010)
   双向优化         渐进最优
      ↓               ↓
   RRT*-Smart ←──→ Informed RRT*
   (2013)           (2014)
   路径优化         椭圆采样
      ↓               ↓
   RT-RRT* ←────→ RRT# 
   (2015)          (2015)
   实时性          动态重规划
      ↓               ↓
   Batch Informed Trees (BIT*)
   (2015) 批量采样优化
              ↓
   Advanced BIT* (ABIT*)
   (2020) 自适应采样
```

**深度技术剖析与演进脉络：**

1. **RRT* (2010) - 最优性突破**：
   ```
   核心创新：Near + Rewire
   
   Near邻域定义：
   r = γ·(log n / n)^(1/d)
   - γ: 常数(通常2×(1+1/d)^(1/d)×μ(Xfree)^(1/d))
   - n: 节点数
   - d: 空间维度
   - μ(Xfree): 自由空间测度
   
   Rewire过程：
   for each x_near in Near(x_new, r):
       if Cost(x_new) + c(x_new, x_near) < Cost(x_near):
           x_near.parent = x_new  // 重连线
   
   性能提升：
   - 路径质量：提升15-30%
   - 收敛速度：O(n log n)
   - 内存开销：增加20%
   ```

2. **Informed RRT* (2014) - 搜索空间优化**：
   ```
   椭圆采样原理：
   当找到初始解cbest后，限制采样空间为：
   {x | ||x-xstart|| + ||x-xgoal|| ≤ cbest}
   
   Tesla AP2.x (2017)实践：
   - 初始全空间采样1000个点
   - 找到解后椭圆采样
   - 路径改进速度提升5倍
   - 最终路径长度减少8%
   ```

3. **Kinodynamic RRT* - 动力学约束处理**：
   ```
   状态空间扩展：
   x = [px, py, pz, vx, vy, vz, ax, ay, az]
   
   前向积分验证：
   x_new = f(x_near, u, Δt)
   其中f为车辆动力学模型
   
   控制空间采样：
   u ∈ U = {加速度×转向角}
   
   Waymo实践(2018)：
   - 5维状态空间[x,y,θ,v,ω]
   - 2维控制空间[a,δ]
   - 积分步长0.1s
   - 规划周期10Hz
   ```

**产业界深度实践案例：**

**Waymo的分层RRT架构(2017-2019)：**
```
三层RRT系统：
┌────────────────────────────────┐
│  战略层RRT (1Hz)               │
│  - 道路网络级别               │
│  - 10km范围                   │
│  - 拓扑结构搜索               │
└────────────────────────────────┘
           ↓
┌────────────────────────────────┐
│  战术层RRT* (10Hz)             │
│  - 车道级别规划               │
│  - 200m范围                   │
│  - 考虑动态障碍物             │
└────────────────────────────────┘
           ↓
┌────────────────────────────────┐
│  操作层Informed RRT* (20Hz)    │
│  - 轨迹级别                   │
│  - 50m范围                    │
│  - 精确避障                   │
└────────────────────────────────┘

并行化策略：
- 8线程并行探索
- Lock-free数据结构
- GPU加速碰撞检测
- 总延迟<50ms
```

**Uber ATG的RRT*优化(2018)：**
```
批量扩展优化：
传统：逐点扩展
优化：批量100点同时扩展

SIMD加速：
- AVX2指令集
- 4个节点并行处理
- 碰撞检测加速3.5倍

自适应采样：
if 障碍物密度高:
    增加采样密度
    减小步长
else:
    稀疏采样
    增大步长

性能指标：
- 成功率：98.5%
- 平均时间：12ms
- 路径质量：接近最优解的1.1倍
```

**MIT RACECAR项目的RT-RRT*(2016)：**
```
实时性保证机制：
1. 任意时间特性：
   - 随时可中断
   - 返回当前最优解
   
2. 分支限界：
   - 维护解的上界
   - 剪枝劣质分支
   
3. 增量式改进：
   while time_available():
       improve_solution()
       
赛车场景性能：
- 速度：120km/h
- 规划频率：50Hz
- 预瞄距离：30m
- 碰撞率：<0.1%
```

**Cruise的Continuous RRT(2020)：**
- 连续空间直接搜索，避免离散化误差
- 贝塞尔曲线连接，保证曲率连续
- 概率道路图(PRM)预处理加速
- 城市复杂路口成功率：97%

### 1.2 基于优化的轨迹规划

#### Lattice Planner的广泛应用

Lattice规划器通过在状态空间中预定义一组可行的运动原语(Motion Primitives)，将连续规划问题转化为图搜索问题。这种方法最早由CMU的Ross等人于2008年提出，在DARPA Urban Challenge中大放异彩，随后成为自动驾驶规划的主流方法之一。

```
Lattice Planner完整技术架构：

状态空间定义：
┌────────────────────────────────────┐
│  State = [x, y, θ, v, a, κ, t]    │
│  x,y: 位置(m)   θ: 航向(rad)      │
│  v: 速度(m/s)   a: 加速度(m/s²)   │
│  κ: 曲率(1/m)   t: 时间戳(s)      │
└────────────────────────────────────┘
            ↓
运动原语生成（离线预计算）：
┌────────────────────────────────────┐
│  前进类(5)   转向类(9)   变道类(6) │
│   ──────→   ╱──────╲   ╱────────  │
│   ═══════►  ╱══════╲  ╱════════   │
│   ········► ╱······╲  ╱········   │
└────────────────────────────────────┘
            ↓
轨迹评估多目标优化：
Cost = w₁·Jsafety + w₂·Jcomfort + w₃·Jefficiency
     + w₄·Jlegality + w₅·Jconsistency
```

**深度技术剖析：**

**运动原语设计原理：**
```
1. 横向运动原语（Lateral Primitives）：
   五次多项式：y(s) = a₀ + a₁s + a₂s² + a₃s³ + a₄s⁴ + a₅s⁵
   边界条件：
   - 起点：[y₀, y'₀, y''₀]
   - 终点：[yf, y'f, y''f]
   
   采样策略（Mercedes实践）：
   - 横向偏移：[-3.5, -1.75, 0, 1.75, 3.5]m
   - 纵向距离：[10, 20, 30, 40, 50]m
   - 组合数量：5×5 = 25条候选路径

2. 纵向运动原语（Longitudinal Primitives）：
   四次多项式：v(t) = b₀ + b₁t + b₂t² + b₃t³ + b₄t⁴
   约束条件：
   - 加速度限制：|a| ≤ 4m/s²
   - 加加速度限制：|j| ≤ 2m/s³
   - 速度范围：[0, vmax]
   
   速度剖面采样：
   - 目标速度：[0, 5, 10, 15, 20, 25, 30]m/s
   - 到达时间：[2, 3, 4, 5, 6]s
   - 组合数量：7×5 = 35条速度剖面
```

**成本函数设计细节：**
```
1. 安全成本(Jsafety)：
   - 碰撞风险：exp(-d_obs/σ)
   - 道路边界：exp(-d_road/σ)
   - 视野盲区：visibility_cost
   权重：w₁ = 1000（最高优先级）

2. 舒适度成本(Jcomfort)：
   - 横向加速度：∫ay²dt
   - 纵向加速度：∫ax²dt
   - 加加速度：∫jerk²dt
   权重：w₂ = 10

3. 效率成本(Jefficiency)：
   - 行程时间：T_total
   - 速度偏差：(v - v_desired)²
   - 路径长度：∫ds
   权重：w₃ = 1

4. 合规成本(Jlegality)：
   - 超速罚分：max(0, v - v_limit)²
   - 车道偏离：lane_deviation²
   - 交规违反：traffic_violation
   权重：w₄ = 100

5. 一致性成本(Jconsistency)：
   - 与上一帧偏差：||traj_new - traj_old||²
   - 防止振荡
   权重：w₅ = 5
```

**Mercedes-Benz S-Class (2013-2018)的工业级Lattice实践：**
```
系统配置：
├─ 处理器：NVIDIA Drive PX2 (8 TOPS)
├─ 更新频率：50Hz (20ms周期)
├─ 预瞄时间：6秒
└─ 规划距离：150米

性能优化技术：
1. 运动原语缓存：
   - 预计算10000+条轨迹
   - 存储为查找表(LUT)
   - 内存占用：~50MB
   
2. 并行评估：
   - CUDA加速成本计算
   - 800条轨迹并行评估
   - 计算时间：<5ms
   
3. 早期剪枝：
   - 碰撞检测提前终止
   - 分层包围盒(BVH)
   - 剪枝率：>70%

实际性能指标：
- 成功率：99.2%（高速公路）
- 舒适度：横向加速度<2m/s²
- 计算延迟：12±3ms
- 紧急避障反应：<100ms
```

**百度Apollo EM Planner深度解析(2018-2020)：**
```
┌─────────────────────────────────────────┐
│      EM Planner完整技术栈               │
├─────────────────────────────────────────┤
│  1. 参考线提供器 (Reference Provider)    │
│     输入：高精地图车道中心线              │
│     处理：                              │
│     - 离散点平滑(QP-Spline)            │
│     - 曲率连续性保证                    │
│     - 多参考线生成(换道场景)            │
│     输出：平滑参考线[s, x(s), y(s), κ(s)]│
├─────────────────────────────────────────┤
│  2. 决策器 (Decision Maker)             │
│     任务分解：                          │
│     - 车道决策：保持/左变/右变          │
│     - 障碍物决策：超车/跟随/让行        │
│     - 速度决策：巡航/减速/停止          │
│     输出：语义化决策序列                │
├─────────────────────────────────────────┤
│  3. 路径规划器 (Path Planner)           │
│     3.1 DP路径生成：                    │
│     - SL坐标系采样                     │
│     - 横向偏移：[-3, -1.5, 0, 1.5, 3]m│
│     - 纵向步长：[5, 10, 15, 20]m       │
│     - 动态规划求解最优路径              │
│                                        │
│     3.2 QP路径优化：                    │
│     min J = ∫[w₁κ² + w₂κ'² + w₃(l-lref)²]ds│
│     s.t. 道路边界约束                   │
│          障碍物避让约束                  │
│          曲率限制约束                    │
├─────────────────────────────────────────┤
│  4. 速度规划器 (Speed Planner)          │
│     4.1 ST图构建：                      │
│     - 障碍物投影到ST空间                │
│     - 安全走廊生成                      │
│                                        │
│     4.2 DP速度生成：                    │
│     - 时间采样：0.1s间隔                │
│     - 速度采样：[-2, -1, 0, 1, 2]m/s增量│
│                                        │
│     4.3 QP速度优化：                    │
│     min J = ∫[w₁a² + w₂j² + w₃(v-vref)²]dt│
│     s.t. 动力学约束                     │
│          ST障碍物约束                    │
└─────────────────────────────────────────┤

关键创新点：
1. Path-Speed解耦：
   - 降低问题维度
   - 并行优化可能
   - 计算效率提升5倍

2. Frenet坐标系：
   - 简化道路跟随
   - 自然的横纵向解耦
   - 便于约束表达

3. 二次规划求解器：
   - OSQP开源求解器
   - ADMM算法
   - 求解时间<10ms
```

### 1.3 数值优化方法

#### 二次规划(QP)在轨迹平滑中的应用

```
典型QP问题形式：
min  J = x^T H x + f^T x
s.t. A_eq · x = b_eq
     A_ineq · x ≤ b_ineq
     lb ≤ x ≤ ub

在轨迹优化中：
- x: 轨迹控制点
- H: 平滑性权重矩阵
- 约束: 动力学限制、避障、道路边界
```

**小鹏NGP(2020)的QP优化器：**
- 使用OSQP求解器
- 分段B样条表示
- 实时求解(<10ms)

#### 非线性优化(NLP)

**IPOPT在Apollo中的应用：**
- 处理非凸避障约束
- 考虑车辆动力学模型
- 计算时间：20-50ms

### 1.4 传统方法的根本局限

尽管传统规划方法在确定性环境下表现良好，但面临以下根本性挑战：

1. **组合爆炸**：多智能体交互场景下状态空间指数增长
2. **手工规则局限**：难以穷举所有驾驶场景
3. **社会规范建模**：无法学习隐式驾驶习惯
4. **计算复杂度**：实时性与最优性的固有矛盾

## 2. 学习型规划的兴起与突破

### 2.1 模仿学习(Imitation Learning)演进

#### 行为克隆(Behavior Cloning)的早期探索

**NVIDIA DAVE-2 (2016)里程碑：**
```
架构极简但影响深远：
┌─────────────────────────────────┐
│   输入: 前视摄像头图像            │
│         ↓                       │
│   CNN特征提取                    │
│   (5 Conv + 3 FC)               │
│         ↓                       │
│   输出: 方向盘转角               │
└─────────────────────────────────┘

关键创新：
- 端到端学习，无需手工特征
- 仅用72小时驾驶数据训练
- 泛化到未见过的道路
```

**Waymo ChauffeurNet (2018)：**
```
输入表征创新 - Perception Feature Map：
┌────────────────────────────────────┐
│  通道1: 道路地图                    │
│  通道2: 交通灯状态                  │
│  通道3: 限速信息                    │
│  通道4: 当前路径                    │
│  通道5: 动态障碍物                  │
│  通道6: 历史轨迹                    │
└────────────────────────────────────┘
         ↓
    ConvLSTM处理时序
         ↓
    输出未来轨迹点
```

关键技术突破：
- **合成扰动增强**：人工生成困难场景
- **因果混淆缓解**：通过dropout随机遮挡
- **闭环仿真评估**：不只是开环指标

#### 逆强化学习(Inverse RL)

**Berkeley DeepDrive (2017-2019)的Maximum Entropy IRL：**
```
专家轨迹 → 推断奖励函数 → 生成类人轨迹

P(τ) ∝ exp(R(τ))
其中R(τ)通过神经网络学习

优势：
- 学习隐式偏好
- 处理多模态行为
- 更好的分布外泛化
```

### 2.2 强化学习在规划中的应用

#### 深度强化学习的突破

**特斯拉FSD Beta (2020-2022)的RL组件：**
```
奖励函数设计(推测)：
R = -w₁·碰撞风险 
    -w₂·车道偏离
    -w₃·急刹急转
    +w₄·行驶进度
    +w₅·舒适度分数

训练策略：
1. 离线RL预训练(大规模车队数据)
2. 仿真环境微调
3. 影子模式验证
4. 逐步部署
```

**Waymo规划器中的MCTS+RL (2021)：**
```
蒙特卡洛树搜索增强：
         根节点
         /   \
      动作1  动作2
      /  \    /  \
    ...  ... ...  ...
    
每个节点：
- 状态价值：V(s)由神经网络估计
- 访问次数：N(s,a)
- 选择策略：UCB1公式
```

#### 离线强化学习的实践

**问题**：在线RL在自动驾驶中风险太高

**解决方案 - Conservative Q-Learning (CQL)：**
```
核心思想：对未见过的动作保守估计

Q_CQL = Q_标准 - α·log∑exp(Q(s,a))
                    a

确保学到的策略不会偏离数据分布太远
```

**Momenta (2021)的离线RL实践：**
- 10亿帧历史驾驶数据
- CQL + IQL混合训练
- 泛化到新城市成功率85%+

### 2.3 混合方法的工程实践

#### 规则引导的学习规划

**小鹏XNGP (2023)架构：**
```
┌─────────────────────────────────┐
│      场景识别器(Transformer)     │
│  识别当前驾驶场景类型            │
└─────────────────────────────────┘
            ↓
     ┌──────┴──────┐
     ↓             ↓
┌─────────┐  ┌─────────┐
│规则规划器│  │神经规划器│
│(紧急情况)│  │(常规驾驶)│
└─────────┘  └─────────┘
     ↓             ↓
     └──────┬──────┘
            ↓
    ┌───────────────┐
    │  安全检查器    │
    │  硬约束验证    │
    └───────────────┘
```

**华为ADS 2.0 (2023)的分层决策：**
1. **高层策略网络**：选择驾驶意图
2. **中层战术规划**：生成参考轨迹
3. **底层轨迹优化**：考虑动力学约束

#### 数据驱动与模型驱动的结合

**Apollo 7.0 (2022) PNC-Net：**
```
输入编码：
┌──────────────────────────┐
│  栅格化BEV特征图          │
│  + 矢量化道路拓扑        │
│  + 智能体历史轨迹        │
└──────────────────────────┘
           ↓
    Transformer编码器
           ↓
┌──────────────────────────┐
│  输出1: 轨迹提议(学习)    │
│  输出2: 成本地图(学习)    │
└──────────────────────────┘
           ↓
    传统优化器精修
```

### 2.4 数据效率与泛化性挑战

#### 数据增强技术

**几何增强：**
- 轨迹扰动：添加高斯噪声
- 时间扭曲：改变速度剖面
- 空间变换：镜像、旋转

**对抗生成：**
```python
# 伪代码示例
adversarial_scene = baseline_scene
for step in range(max_steps):
    gradient = compute_difficulty_gradient(scene)
    adversarial_scene += ε * gradient
    if safety_violated(adversarial_scene):
        break
```

**场景重组：**
- 从不同场景提取智能体
- 组合成新的交互场景
- 保持物理合理性

#### 元学习与快速适应

**MAML在规划中的应用(Stanford, 2020)：**
```
元训练：
for task in tasks:
    θ' = θ - α∇L_task(θ)  # 内循环
    meta_loss += L_task(θ')
θ = θ - β∇meta_loss      # 外循环

效果：
- 新城市3小时数据即可适应
- 相比从头训练提升10倍效率
```

## 3. 轨迹预测与交互式规划

### 3.1 多智能体行为预测

#### 从独立预测到联合预测

**早期方法(2016-2018) - 独立预测：**
```
每个智能体独立建模：
Agent_i → LSTM/GRU → Future_trajectory_i

问题：
- 忽略交互
- 预测冲突
- 累积误差
```

**Social LSTM/GAN (2018-2020)：**
```
社交池化机制：
┌─────────────────────────────┐
│  Agent_1 ─→ LSTM_1 ←─┐      │
│                      ↓      │
│  Agent_2 ─→ LSTM_2 ← Pool   │
│                      ↑      │
│  Agent_3 ─→ LSTM_3 ←─┘      │
└─────────────────────────────┘

创新：
- 隐状态共享
- 空间关系编码
- 生成多模态预测
```

**VectorNet (2020, Waymo)：**
```
矢量化表示：
道路元素 → 折线段 → 子图编码
智能体轨迹 → 折线段 → 子图编码
         ↓
    全局交互图
         ↓
    GNN消息传递
         ↓
   多模态轨迹输出
```

关键优势：
- 处理不规则道路拓扑
- 长程依赖建模
- 计算效率高

#### Scene Transformer架构演进

**Waymo (2021) Scene Transformer：**
```
输入token化：
┌──────────────────────────────────┐
│  时间步1: [Agent₁, Agent₂, ...]  │
│  时间步2: [Agent₁, Agent₂, ...]  │
│  ...                             │
└──────────────────────────────────┘
            ↓
    Factorized Attention:
    1. 时间自注意力(per agent)
    2. 空间自注意力(per timestep)
    3. 全局自注意力
            ↓
     联合轨迹分布
```

性能提升：
- minADE: 降低30%
- 碰撞率：降低50%
- 推理速度：40ms@8agents

**Tesla FSD V11 (2022)的预测架构(推测)：**
```
多尺度时空Transformer：
┌─────────────────────────────┐
│   短程预测头(0-2s)          │
│   - 高频更新               │
│   - 细粒度轨迹             │
├─────────────────────────────┤
│   中程预测头(2-5s)          │
│   - 意图识别               │
│   - 交互建模               │
├─────────────────────────────┤
│   长程预测头(5-10s)         │
│   - 目标推断               │
│   - 粗粒度路径             │
└─────────────────────────────┘
```

### 3.2 博弈论方法在规划中的应用

#### 多智能体博弈建模

**Level-K推理模型：**
```
Level-0: 随机/反应式行为
Level-1: 假设他人是Level-0，最优响应
Level-2: 假设他人是Level-1，最优响应
...

实际应用(Uber ATG, 2019)：
- 大部分驾驶员: Level-1到Level-2
- 激进驾驶员: Level-0
- 谨慎驾驶员: Level-3
```

**逆向归纳(Backward Induction)：**
```
游戏树示例 - 并线场景：
        自车并线?
       /        \
    并线        不并线
    /  \          |
  让行 不让    继续直行
   |    |         |
  成功 碰撞     保持现状

通过逆向推理计算纳什均衡
```

#### 社会价值取向(SVO)建模

**MIT (2020)的SVO-based Planning：**
```
SVO角度分布：
利他 ←──────────→ 利己
-45°     0°      45°

驾驶员分类：
- 合作型(60%): SVO ∈ [-22.5°, 22.5°]
- 利己型(30%): SVO ∈ [22.5°, 45°]
- 竞争型(10%): SVO > 45°

规划策略：
根据估计的SVO调整自车行为激进度
```

### 3.3 交互感知规划

#### 条件预测与规划耦合

**Joint Prediction and Planning (JPP)：**
```
传统解耦方式：
预测 → 规划 (单向)

JPP耦合方式：
┌─────────────────────┐
│   预测  ←→  规划     │
│   相互影响，迭代优化 │
└─────────────────────┘

实现方式：
for iteration in range(K):
    他车轨迹 = 预测(自车规划)
    自车规划 = 优化(他车轨迹)
```

**INTERACTION Dataset挑战赛优胜方案(2022)：**
- 显式建模意图：左转/直行/右转
- 条件VAE生成多样化轨迹
- 社交力模型约束

#### 可解释的交互规划

**Waymo的可解释框架(2023)：**
```
交互图构建：
节点：智能体
边：潜在交互

边权重类型：
- 空间邻近度
- 速度相关性
- 历史交互模式
- 意图相似度

可视化输出：
┌────────────────────────┐
│  "Agent2正在让行"      │
│  "Agent3可能抢道"      │
│  "建议减速避让"        │
└────────────────────────┘
```

### 3.4 规划中的不确定性处理

#### 概率规划方法

**置信度传播：**
```
不确定性来源：
1. 感知不确定性 ±0.2m
2. 预测不确定性 ±1.0m@3s
3. 控制不确定性 ±0.1m

传播方式：
蒙特卡洛采样 or 高斯传播
```

**风险感知规划指标：**
```
CVaR (Conditional Value at Risk):
不考虑最坏5%情况下的平均风险

应用：
轨迹评分 = α·期望收益 - β·CVaR风险
```

## 4. 产业实践对比分析

### 4.1 主要厂商技术路线对比

| 厂商 | 规划架构 | 核心技术 | 数据规模 | 部署状态 |
|------|---------|----------|----------|----------|
| **Tesla FSD** | 端到端神经网络 | Transformer+占据网络 | 100亿英里 | 北美40万+用户 |
| **Waymo** | 混合架构 | 行为预测+优化 | 2000万英里路测 | 4城市Robotaxi |
| **小鹏XNGP** | 模块化+学习 | BEV+轻地图 | 10亿公里 | 全国推送 |
| **华为ADS** | 分层决策 | GOD网络+规则 | 未公开 | 问界/极狐量产 |
| **Momenta** | 双线并行 | 数据驱动闭环 | 数亿公里 | L2量产+L4测试 |
| **Apollo** | 开源模块化 | EM Planner | 1亿公里仿真 | Robotaxi试运营 |

### 4.2 关键技术演进时间线

```
2016 ├─ 纯规则规划主导
     │  A*, RRT, 多项式轨迹
     │
2017 ├─ 行为克隆初探
     │  NVIDIA DAVE-2影响力扩散
     │
2018 ├─ 模仿学习改进
     │  ChauffeurNet展示潜力
     │
2019 ├─ 预测规划分离成熟
     │  Social LSTM/GAN兴起
     │
2020 ├─ 图神经网络应用
     │  VectorNet矢量化表示
     │
2021 ├─ Transformer渗透
     │  Scene Transformer联合预测
     │
2022 ├─ 混合架构成主流
     │  学习+优化结合
     │
2023 ├─ 端到端规划爆发
     │  FSD V12纯神经网络
     │
2024 ├─ 世界模型探索
     └─ 生成式规划研究
```

### 4.3 技术挑战与解决方案矩阵

| 挑战 | 传统方法 | 学习方法 | 混合方案 |
|------|---------|----------|----------|
| **长尾场景** | ❌ 规则难穷举 | ⚠️ 数据稀疏 | ✅ 规则兜底+学习泛化 |
| **实时性** | ⚠️ 复杂度高 | ✅ 前向推理快 | ✅ 分层决策 |
| **可解释性** | ✅ 逻辑清晰 | ❌ 黑盒 | ⚠️ 部分可解释 |
| **安全保证** | ✅ 形式化验证 | ❌ 概率保证 | ⚠️ 安全边界约束 |
| **数据需求** | ✅ 无需数据 | ❌ 海量数据 | ⚠️ 中等规模 |

### 4.4 中国特色场景的规划挑战

#### 复杂交通流处理

**中国城市道路特点：**
```
挑战场景分布：
├─ 非机动车混行 (35%)
├─ 行人横穿 (25%)
├─ 外卖/快递穿插 (20%)
├─ 违章车辆 (15%)
└─ 施工/事故 (5%)

应对策略：
1. 多模态意图识别
2. 保守型安全边界
3. 社会规范学习
```

**小鹏XNGP城市场景处理：**
- 特殊目标识别：外卖车、三轮车
- 中国式加塞处理：渐进式让行
- 无保护左转：爬行策略

#### 高密度交互场景

**华为ADS 2.0的解决方案：**
```
时空联合规划：
┌─────────────────────────┐
│  空间维度：多车道选择    │
│  时间维度：加减速时机    │
│  交互维度：博弈预测     │
└─────────────────────────┘
        ↓
   4D成本地图优化
        ↓
   最优时空轨迹
```

### 4.5 算力与实时性权衡

#### 边缘计算约束

**典型算力预算分配：**
```
总算力: 100-200 TOPS
├─ 感知: 40-50%
├─ 预测: 20-25%
├─ 规划: 20-25%
└─ 控制: 5-10%

规划模块细分：
├─ 行为决策: 5 TOPS
├─ 轨迹生成: 10 TOPS
├─ 安全检查: 5 TOPS
└─ 备份方案: 5 TOPS
```

**优化策略：**
1. **模型量化**：FP32→INT8，性能损失<1%
2. **稀疏化**：剪枝70%参数，速度提升3x
3. **分级调度**：关键路径10Hz，次要路径2Hz
4. **区域裁剪**：只处理相关区域

### 4.6 数据闭环最佳实践

#### Tesla的数据飞轮

```
数据收集 → 自动标注 → 模型训练 → 影子模式
    ↑                              ↓
    └──────── 触发条件 ←───────────┘

触发条件示例：
- 人工接管
- 预测误差>阈值
- 新场景检测
- 不确定性高
```

#### 国内厂商的数据策略

**小鹏汽车：**
- 用户授权后收集
- 脱敏处理
- 仿真重建训练

**理想汽车：**
- 场景挖掘系统
- 自动化标注流水线
- 增量学习部署

## 5. 未来技术趋势展望

### 5.1 大语言模型驱动的规划

#### GPT-4V/Claude在规划中的探索

```
LLM辅助规划架构：
┌──────────────────────────┐
│   场景理解(VLM)          │
│   "前方施工，建议变道"    │
└──────────────────────────┘
            ↓
┌──────────────────────────┐
│   常识推理(LLM)          │
│   交通规则+社会规范      │
└──────────────────────────┘
            ↓
┌──────────────────────────┐
│   规划决策生成           │
│   自然语言→结构化指令    │
└──────────────────────────┘
```

**DriveGPT (毫末智行, 2023)：**
- 120亿参数视觉语言模型
- 场景理解+决策解释
- 4000万公里数据训练

### 5.2 世界模型与想象力规划

#### 预测未来的生成模型

**GAIA-1 (Wayve, 2023)：**
```
输入: 历史视频+动作
     ↓
世界模型(扩散模型)
     ↓
输出: 未来场景视频

应用：
1. 反事实推理
2. 闭环评估
3. 场景生成
```

**UniSim (Waabi, 2023)：**
- 神经场景表示
- 可控场景生成
- 物理真实渲染

### 5.3 端到端规划的极限探索

#### 纯神经网络规划的边界

**优势：**
- 无需手工设计
- 持续改进
- 处理复杂交互

**挑战：**
- 安全认证困难
- 极端场景泛化
- 法规合规性

#### 混合架构的长期主导

```
预期演进路径：
2024: 70%规则 + 30%学习
2025: 50%规则 + 50%学习  
2026: 30%规则 + 70%学习
2027+: 动态自适应比例
```

### 5.4 规划系统的形式化验证

#### 安全性证明方法

**形式化方法应用：**
```
模型检查：
规划器 → 抽象模型 → 性质验证
              ↓
        安全性证明/反例

符号执行：
探索所有可能路径
证明无碰撞/死锁
```

**ISO 26262/21448合规：**
- ASIL-D级别要求
- SOTIF安全分析
- 失效模式分析

## 6. 关键经验总结

### 6.1 工程实践要点

1. **分层架构设计**
   - 战略层：路线规划
   - 战术层：行为决策  
   - 操作层：轨迹生成

2. **冗余安全设计**
   - 主规划器+备份规划器
   - 规则兜底保证
   - 紧急制动系统

3. **实时性优化**
   - 异步并行架构
   - 增量式计算
   - 自适应降级策略

### 6.2 数据驱动最佳实践

1. **场景挖掘**
   - 自动发现corner case
   - 主动学习策略
   - 困难样本重采样

2. **仿真验证**
   - 蒙特卡洛测试
   - 对抗场景生成
   - 回归测试自动化

3. **持续优化**
   - A/B测试框架
   - 指标体系设计
   - 用户反馈闭环

### 6.3 技术选型建议

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| L2高速 | Lattice+优化 | 成熟可靠 |
| L2城市 | 混合学习 | 平衡复杂度 |
| L4限定区域 | 模块化+冗余 | 安全优先 |
| 泊车 | 端到端 | 场景受限 |

## 结语

规划算法作为自动驾驶的核心决策模块，正在经历从规则驱动到数据驱动的深刻变革。传统方法提供了坚实的理论基础和安全保证，而学习方法展现了处理复杂交互和长尾场景的巨大潜力。

未来的规划系统将是混合智能的集大成者：既有规则的确定性，又有学习的灵活性；既能处理日常驾驶，又能应对极端情况。随着算力提升、数据积累和算法创新，规划系统将越来越接近人类驾驶员的决策水平，最终实现真正的自主驾驶。

从2016年的规则主导到2024年的端到端浪潮，规划算法的演进见证了人工智能技术在实际工程中的落地过程。这不仅是技术的进步，更是对复杂现实世界建模能力的提升。下一个突破或许来自世界模型、或许来自更强大的基础模型，但可以确定的是，规划算法仍将是自动驾驶技术竞争的核心战场。